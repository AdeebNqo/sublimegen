/*

Copyright 2015 Zola Mahlaza <adeebnqo@gmail.com>
20 January 2015

This is the golang (and enhanced) version of the source code
written in C++ by Kendrick Ledet ( https://github.com/kennyledet/Algorithm-Implementations/blob/master/Thompsons_Construction_Algorithm/C%2B%2B/AlexMathew/RE_to_NFA.cpp)

This package handles the checking of whether a regex
is a subregex, that is, given regexes a, b -- it will
determine whether L(a) \subset L(b). Here, L(x) refers
to the language generated by the regex x.

It will also order regexes starting from specific to more
general
*/

package regfa

import (
        "container/list"
)


//this is the beginning of the NFA, it's components
//and it's methods
//-------------------------------------------------
type Transition struct{
    From int
    To int
    Symbol string
}
type NFA struct{
    Vertices list.List
    Transitions list.List
    FinalState int
}

func (somenfa NFA) GetVertexCount(){
    return len(somenfa.Vertices)
}
func (somenfa NFA) SetVertex(int number){
    for i:=0; i< number; i++{
        somenfa.Vertices.PushBack(i)   
    }
}
func (somenfa NFA) SetTransition(int from, int to, string symbol){
    somenfa.PushBack(Transition{From:from, To:to, Symbol:symbol})
}
func (somenfa NFA) SetFinalState(int finalstate){
    somenfa.FinalState = finalstate
}
func (somenfa NFA) GetFinalState(){
    return somenfa.FinalState
}

//the following are methods that operate on an NFA
//--------------------------------------------------

func Concatenate(first NFA, second NFA) NFA{
    result := NFA{}
    result.SetVertex(first.GetVertexCount()+second.GetVertexCount())
    
    //getting transitions from first nfa
    for item := first.Transitions.Front(); item!=nil; item=item.Next(){
        newtranstion := item.(Transition)
        result.SetTransition(newtranstion.From,  newtranstion.To, newtranstion.Symbol)
    }
    
    result.SetTransition(first.GetFinalState(), first.GetVertexCount(), "^")
    
    //getting transitions from second nfa
    for item := second.Transitions.Front(); item!=nil; item=item.Next(){
        newtranstion := item.(Transition)
        result.SetTransition(newtranstion.From+ first.GetVertexCount(),  newtranstion.To + first.GetVertexCount(), newtranstion.Symbol)
    }
    
    result.SetFinalState(first.GetVertexCount() + second.GetVertexCount()-1)
    
    return result
}


func Kleene(somenfa NFA){
    oldvertexcount := somenfa.GetVertexCount() 
    result = {}
    result.SetVertex(oldvertexcount+2)
    
    result.SetTransition(0,1,"^")
    
    for item:=somenfa.Front(), item!=nil, item=item.Next(){
        newtrans := item.(Transition)
        result.SetTransition(newtrans.From +1, newtrans.To+1, newtrans.Symbol)
    }
    
    result.SetTransition(oldvertexcount, oldvertexcount+1, "^")
    result.SetTransition(oldvertexcount,1,"^")
    result.SetTransition(0,oldvertexcount+1,"^")
    
    result.SetFinalState(oldvertexcount+1)
    return result
}

func OR(nfas list.List) NFA{
    result := NFA{}
    vertexcount := 2
    
    for item:=nfas.Front(); item!=nil; item=item.Next(){
        currnfa := item.(NFA)
        vertexcount+=currnfa.GetVertexCount()
    }
    result.SetVertex(vertexcount)
    
    addertrack := 1
    for item:=nfas.Front(); item!=nil; item=item.Next(){
        currnfa := item.(NFA)
        
        result.SetTransition(0, addertrack, "^")
        for currtransitem := currnfa.Transitions; currtransitem!=nil; currtransitem=currtransitem.Next(){
            currtrans = currtransitem.(Transition)
            result.SetTransition(currtrans.From + addertrack, currtrans.To + addertrack, currtrans.Symbol)
        }
        addertrack += currnfa.GetVertexCount()
        result.SetTransition(addertrack-1, vertexcount-1, "^")
    }
    result.SetFinalState(vertexcount-1)
    return result
    
}

func getNFAfromRegex(regex string) NFA{
    var operators list.List
    var operands list.List //list of NFA's
    var op_sym string
    var op_count int
    var cur_sym string
    var new_sym NFA
    
    for _, charvalue := range regex{
        cur_sym = string(charvalue)
        
        if cur_sym!="(" && cur_sym!=")" && cur_sym!="*" && cur_sym!="|" && cur_sym!="."{
            new_sym = NFA{}
            new_sym.SetVertex(2)
            new_sym.SetTransition(0,1,cur_sym)
            new_sym.SetFinalState(1)
            operands.PushFront(new_sym)
        }else{
            if cur_sym=="*"{
                star_sym := operands.Front()
                operands.Remove(star_sym)
                operands.PushFront(Kleene(star_sym))
            }else if cur_sym=="." || cur_sym=="|" || cur_sym=="("{
                operators.PushFront(cur_sym)
            }else{
                op_count = 0
                
            }
        }
    }
}